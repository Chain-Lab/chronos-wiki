# 共识算法

## 共识节点选取

共识节点的选取利用了可验证延迟函数(Verifiable Delay Function, VDF)和可验证随机函数(Verifiable Random Function, VRF)来实现

>可验证随机函数通过在维护区块链的同时计算$m^{2^t}$的方式来产生随机数，$t$ 是时间参数，通过调整该参数可以设定 VDF 的计算间隔，$m$是一个随机数种子。
>
>一段计算间隔被称为共识周期，每段共识周期下选出的共识节点是不同的。

### VDF 生成随机数

VDF 按照如下图所示的方式生成随机数，在创世区块中会包含一个最初的随机数种子$seed_0$，节点计算VDF的流程如下

* 从创世区块中获取到时间参数 $t$，然后从最新区块中获取到最新的随机数种子 $seed_n$ (假设现在计算了 $n$ 轮)
* 开启线程计算 $seed_{n+1} = {seed_n}^{2^t}$，并且还会计算一个证明 $pi$，其他节点可以通过 $pi$ 在 $O(log \ t)$的时间复杂度下完成对随机数正确性的验证
* 如果本轮计算完成，暂停计算。直到收到下一个区块并且区块中记录的VDF与本轮计算的一致后再开始新一轮计算
* 如果本地节点被选为打包节点，则将新的VDF放入到新区块中，发布区块后开始新一轮计算

每一轮VDF的计算由区块中记录的 $seed, pi$ 更新后开始，每个节点开始计算之前会通过前一轮的参数来验证区块中包含的计算参数是否正确

![image-20221225115129937](https://imgs.decision01.com/202212251151234.png)

### VRF 选取共识节点

VRF 输入私钥和消息，生成一个可以验证的随机数和证明
$$
VRF(privateKey, message) = (random, pi)
$$
通过设置 VRF 中输出时使用的随机函数，可以让 $random$ 落在$[0, 2^{256} -1]$的区间内，可以利用它来进行共识节点的选取。

各个节点以每轮 VDF 得到的随机数作为 $message$,使用本地节点的私钥通过 VRF 输出随机数，如果$\frac{random}{2^{256}} < p$，则该节点为共识节点。$p$ 是一个选取的参数，用来调整每一个共识周期下选取的节点占总体节点的百分比。

和 VDF 一样，节点生成随机数的同时也需要生成一个简短的证明 $pi$ ，需要向其他节点出示这个证明 $pi$ 来证明自己生成的随机数是正确的。

> 这里参考了 Algorand 公链的共识算法实现，Algorand 的抽签算法的步骤如下：
>
> 1. 假设所有参与选举的节点持有的 token 数量为 $W$
>
> 2. 引入 subuser 的概念，每个 subuer 需要至少 $t$ 个 token， 那么一共有$n = \lfloor \frac{W}{t} \rfloor$个 subuser 参与选举
>
> 3. 假设某个参选节点共有 $w$ 个 token，那么它在本次选举中就有 $\lfloor \frac{w}{t} \rfloor$个 subuser 
>
> 4. 假设最终需要选取 $s$ 个 subuser，那么就是在这 $n$ 个 subuser 中做 $n$ 次独立重复实验，其结果满足二项分布
>
> 5. 所以，每个参选节点有多个 subuser，相当于把这 $n$ 次独立实验分到了各个节点中进行，在每个节点下独立实验都满足二项分布
>
> 6. 在每个节点下利用VRF，并且划分 $n$ 个区间，根据 VRF 的输出结果在输出范围的位置来判断本次抽签落入到哪个区间，如果在第 $i$ 个区间内，则本轮抽中 $i$ 个 subuser
>
>    判断的方式：例如 VRF 的输出范围是 $[0, 2^{256} - 1]$，VRF 本次输出的随机数为 $random$，计算 $p = \frac{random}{2^{256}}$，然后利用这个 $p$ 来确定它在这$n$个区间的哪个位置。
>
> <img src="https://imgs.decision01.com/202212251516181.png" alt="image-20221225151615621" style="zoom: 50%;" />
>
> 在我们的实现下，相当于每个节点都只有一个 subuser，那么就是做一次独立分布实验，然后判断它是否掉落在 $[0, p)$ 的范围内

### 无验证的节点选取

由于需要额外的通信和验证，在目前实现的节点代码中没有用到 VRF 来生成随机数和验证，而是使用了一种简单的方式来进行节点的选取。

每个节点在初始化时会生成本地的钱包，它有一个256位的私钥和对应的512位的公钥，以及经过 base58 编码后得到的地址。而节点在连接到其他邻居节点后会互换地址信息，所以一个节点会有一个地址表用来存储邻居节点的地址。可以通过对地址进行 base58 解码来得到512位长的公钥。

在这样的场景下就可以实现不需要额外发送证明信息的节点选取，假设节点的公钥为 $pk$，VDF 本轮计算得到的随机数为 $seed$，以及设定的选取参数为 $p$ 表示每一轮选取节点的百分比，节点可以进行如下的计算
$$
p' = \frac{pk\ \cdot \ seed }{2^{256}}
$$
如果 $p' < p$，那么该节点就是共识节点，可以进行共识投票。它遍历本地存储的地址表，利用同样的方式计算并判断自己的邻居中是否有共识节点。

## 共识投票

> **投票逻辑在 v1.2.0 版本中删除，由共识节点直接打包后选取优先级最高的区块**

在一轮共识周期下，一个节点被选为共识节点后就可以向其他的邻居节点（如果存在邻居节点是共识节点的话）投票。节点之间会交换自身的时间戳信息、高度信息，于是一个共识节点可以根据收集到的邻居节点的时间戳信息来查找一个当前和自己的时间戳最接近的另一个共识节点投票。

投票环节下，每个节点会维护一个投票的字典，用来表示某个节点被哪些节点投票

```json
{
	"addr1": ["addr2", "addr3"],           // addr1 被 addr2 和 addr3 投票
	"addr2": ["addr1"]                     // addr2 被 addr1 投票
    ...
}
```

并且，在原有的互换时间戳、区块高度信息的基础上，互相交换这个投票字典，如果本地节点没有的投票信息，则合并到当前维护的字典中。

在收到其他节点发来的投票字典后，会判断本地的字典和其他节点的字典是否一致。只有和所有节点的投票字典一致后才认为本轮共识投票完成。



