# 区块缓冲区与扁平化

## 缓冲区需求

缓冲区的设计主要是为了避免区块出现分叉，区块分叉需要处理较为麻烦的回退重组逻辑。

每一次共识通过 VDF + VRF 的方式会选取出一定数量的节点进行区块的打包，但是广播并不能保证区块都难同时到达其他节点，在选取最优区块时就会出现问题。所以，缓冲区的设计在于保证后续的最优区块到达节点后能够在缓冲区内替换旧区块，并且保证后续的出现的区块能够成链（这个过程也比较类似于区块确认）。

## 缓冲树

考虑这样一个缓冲结构：从数据库已存储的区块 $latestBlock_i$ 开始，不同的节点会打包出不同的后继区块 $block_{(i + 1, j)}$，这里的 $i$ 表示最新区块高度，$j$ 表示不同节点所打包的区块，假设每次恒定选取 $n$ 个节点则有 $j \in [0, n]$，这里都有 $prev(block_{(i + 1, j)}) = latestBlock_i$

此时缓冲区的第 1 层会有 $n$ 个区块，进一步，在第 2 层中进行打包时，每个节点可以选取它们的视图下的最优区块进行打包（由于延迟的原因，打包时每个节点的缓冲区不一定是一致的）。此时就会出现不同区块的前驱是不一致的情况，因为打包它们的节点在打包时所选取的前驱是不同的（由于延迟的存在而使得缓冲区不一致所导致）

这样就会形成一棵缓冲树的结构：

![image-20231220144743454](./assets/image-20231220144743454.png)

图中只是作为一个示意图，在实际的情况下每一层的节点数量不会出现很大的差异；红色区块为一个缓冲区下的最优区块，由于要保证形成链式结构，所以只能从最优区块的后继区块中进行选取。

### 实现

在具体的实现上，需要两个 channel 作为任务接收队列，对应地会有两个 goroutine 对任务进行处理，第一个队列接收区块并进行处理，首先判断区块是否完全满足以下条件：

1. 前一个区块非数据库中的最新区块
2. 前一个区块不在缓冲区中
3. 前一个区块未被处理过

如果满足该条件，放入到第二队列中等待处理，而在第二队列中循环处理每个区块也是类似的方法

如果满足1、2，但是不满足3，说明前置区块被处理，但不是最优区块，但是可以放入缓冲区中等待弹出；

如果满足3，但是不满足1、2，则需要和对应高度上的已选定区块进行对比，并且尝试替换，替换后需要更新缓冲区中高度后续区块（因为发生了替换，所以原来选定的最优区块无法成链状）；

具体的实现在 core/buffer 中，非扁平化的代码在（branch v1.0.1 - eaf2379 - opti: block buffer flatten）之前的版本中

## 扁平化

缓冲树的一个性质是，后继可能选取的区块只能保证是在初始最优区块的后续区块中进行选取，基于此可以将缓冲区进行扁平化。

正如对缓冲区的实现中所写的，每个高度下选取的区块的前一个区块一定也在被选定区块中，所以，可以不保存其他的区块信息（因为只要在本地出现，被处理过，那么剩下的区块一定是最优的）

扁平化只需要不保存原有的那一部分区块即可，具体的实现在（branch v1.0.1 - eaf2379 - opti: block buffer flatten）
